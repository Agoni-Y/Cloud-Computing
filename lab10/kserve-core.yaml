# Source: kserve/templates/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  labels:
    app.kubernetes.io/instance: kserve-controller-manager
    app.kubernetes.io/managed-by: kserve-controller-manager
    app.kubernetes.io/name: kserve-controller-manager
  name: kserve-controller-manager
---
# Source: kserve/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: inferenceservice-config
  namespace: kserve
data:
  _example: |-
    ################################
    #                              #
    #    EXAMPLE CONFIGURATION     #
    #                              #
    ################################

    # This block is not actually functional configuration,
    # but serves to illustrate the available configuration
    # options and document them in a way that is accessible
    # to users that `kubectl edit` this config map.
    #
    # These sample configuration options may be copied out of
    # this example block and unindented to be in the data block
    # to actually change the configuration.

    # ====================================== EXPLAINERS CONFIGURATION ======================================
    # Example
    explainers: |-
      {
          "art": {
              "image" : "kserve/art-explainer",
              "defaultImageVersion": "latest"
          }
      }
    # Art Explainer runtime configuration
     explainers: |-
        {
            # Art explainer runtime configuration
            "art": {
                # image contains the default Art explainer serving runtime image uri.
                "image" : "kserve/art-explainer",

                # defautltImageVersion contains the Art explainer serving runtime default image version.
                "defaultImageVersion": "latest"
            }
        }
    # ====================================== ISVC CONFIGURATION ======================================
    # Example - setting custom annotation
     inferenceService: |-
       {
         "serviceAnnotationDisallowedList": [
            "my.custom.annotation/1"
         ],
         "serviceLabelDisallowedList": [
            "my.custom.label.1"
         ]
       }
    # Example - setting custom annotation
    inferenceService: |-
      {
        # ServiceAnnotationDisallowedList is a list of annotations that are not allowed to be propagated to Knative
        # revisions, which prevents the reconciliation loop to be triggered if the annotations is
        # configured here are used.
        # Default values are:
        #  "autoscaling.knative.dev/min-scale",
        #  "autoscaling.knative.dev/max-scale",
        #  "internal.serving.kserve.io/storage-initializer-sourceuri",
        #  "kubectl.kubernetes.io/last-applied-configuration"
        # Any new value will be appended to the list.
        "serviceAnnotationDisallowedList": [
          "my.custom.annotation/1"
        ],
        # ServiceLabelDisallowedList is a list of labels that are not allowed to be propagated to Knative revisions
        # which prevents the reconciliation loop to be triggered if the labels is configured here are used.
        "serviceLabelDisallowedList": [
          "my.custom.label.1"
        ]
      }
    # Example - setting custom resource
    inferenceService: |-
      {
        "resource": {
          "cpuLimit": "1",
          "memoryLimit": "2Gi",
          "cpuRequest": "1",
          "memoryRequest": "2Gi"
        }
      }
    # Example - setting custom resource
    inferenceService: |-
      {
        # resource contains the default resource configuration for the inference service.
        # you can override this configuration by specifying the resources in the inference service yaml.
        # If you want to unbound the resource (limits and requests), you can set the value to null or ""
        # or just remove the specific field from the config.
        "resource": {
           # cpuLimit is the limits.cpu to set for the inference service.
           "cpuLimit": "1",

           # memoryLimit is the limits.memory to set for the inference service.
           "memoryLimit": "2Gi",

           # cpuRequest is the requests.cpu to set for the inference service.
           "cpuRequest": "1",

           # memoryRequest is the requests.memory to set for the inference service.
           "memoryRequest": "2Gi"
        }
     }
     # ====================================== STORAGE INITIALIZER CONFIGURATION ======================================
     # Example
     storageInitializer: |-
       {
           "image" : "kserve/storage-initializer:latest",
           "memoryRequest": "100Mi",
           "memoryLimit": "1Gi",
           "cpuRequest": "100m",
           "cpuLimit": "1",
           "enableDirectPvcVolumeMount": true,
           "enableModelcar": false,
           "cpuModelcar": "10m",
           "memoryModelcar": "15Mi"
       }
     storageInitializer: |-
       {
           # image contains the default storage initializer image uri.
           "image" : "kserve/storage-initializer:latest",

           # memoryRequest is the requests.memory to set for the storage initializer init container.
           "memoryRequest": "100Mi",

            # memoryLimit is the limits.memory to set for the storage initializer init container.
           "memoryLimit": "1Gi",

           # cpuRequest is the requests.cpu to set for the storage initializer init container.
           "cpuRequest": "100m",

           # cpuLimit is the limits.cpu to set for the storage initializer init container.
           "cpuLimit": "1",

           # enableDirectPvcVolumeMount controls whether users can mount pvc volumes directly.
           # if pvc volume is provided in storageuri then the pvc volume is directly mounted to /mnt/models in the user container.
           # rather than symlink it to a shared volume. For more info see https://github.com/kserve/kserve/issues/2737
           "enableDirectPvcVolumeMount": true,

           # enableModelcar enabled allows you to directly access an OCI container image by
           # using a source URL with an "oci://" schema.
           "enableModelcar": false,

           # cpuModelcar is the cpu request and limit that is used for the passive modelcar container. It can be
           # set very low, but should be allowed by any Kubernetes LimitRange that might apply.
           "cpuModelcar": "10m",

           # cpuModelcar is the memory request and limit that is used for the passive modelcar container. It can be
           # set very low, but should be allowed by any Kubernetes LimitRange that might apply.
           "memoryModelcar": "15Mi",

           # uidModelcar is the UID under with which the modelcar process and the main container is running.
           # Some Kubernetes clusters might require this to be root (0). If not set the user id is left untouched (default)
           "uidModelcar": 10
       }

     # ====================================== CREDENTIALS ======================================
     # Example
     credentials: |-
       {
          "storageSpecSecretName": "storage-config",
          "storageSecretNameAnnotation": "serving.kserve.io/storageSecretName",
          "gcs": {
              "gcsCredentialFileName": "gcloud-application-credentials.json"
          },
          "s3": {
              "s3AccessKeyIDName": "AWS_ACCESS_KEY_ID",
              "s3SecretAccessKeyName": "AWS_SECRET_ACCESS_KEY",
              "s3Endpoint": "",
              "s3UseHttps": "",
              "s3Region": "",
              "s3VerifySSL": "",
              "s3UseVirtualBucket": "",
              "s3UseAnonymousCredential": "",
              "s3CABundle": ""
          }
       }
     # This is a global configuration used for downloading models from the cloud storage.
     # You can override this configuration by specifying the annotations on service account or static secret.
     # https://kserve.github.io/website/master/modelserving/storage/s3/s3/
     # For a quick reference about AWS ENV variables:
     # AWS Cli: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-envvars.html
     # Boto: https://boto3.amazonaws.com/v1/documentation/api/latest/guide/configuration.html#using-environment-variables
     #
     # The `s3AccessKeyIDName` and `s3SecretAccessKeyName` fields are only used from this configmap when static credentials (IAM User Access Key Secret)
     # are used as the authentication method for AWS S3.
     # The rest of the fields are used in both authentication methods (IAM Role for Service Account & IAM User Access Key Secret) if a non-empty value is provided.
     credentials: |-
       {
          # storageSpecSecretName contains the secret name which has the credentials for downloading the model.
          # This option is used when specifying the storage spec on isvc yaml.
          "storageSpecSecretName": "storage-config",

          # The annotation can be specified on isvc yaml to allow overriding with the secret name reference from the annotation value.
          # When using storageUri the order of the precedence is: secret name reference annotation > secret name references from service account
          # When using storageSpec the order of the precedence is: secret name reference annotation > storageSpecSecretName in configmap
          "storageSecretNameAnnotation": "serving.kserve.io/storageSecretName",
          # Configuration for google cloud storage
          "gcs": {
              # gcsCredentialFileName specifies the filename of the gcs credential
              "gcsCredentialFileName": "gcloud-application-credentials.json"
          },

          # Configuration for aws s3 storage. This add the corresponding environmental variables to the storage initializer init container.
          # For more info on s3 storage see https://kserve.github.io/website/master/modelserving/storage/s3/s3/
          "s3": {
              # s3AccessKeyIDName specifies the s3 access key id name
              "s3AccessKeyIDName": "AWS_ACCESS_KEY_ID",

              # s3SecretAccessKeyName specifies the s3 secret access key name
              "s3SecretAccessKeyName": "AWS_SECRET_ACCESS_KEY",

              # s3Endpoint specifies the s3 endpoint
              "s3Endpoint": "",

              # s3UseHttps controls whether to use secure https or unsecure http to download models.
              # Allowed values are 0 and 1.
              "s3UseHttps": "",

              # s3Region specifies the region of the bucket.
              "s3Region": "",

              # s3VerifySSL controls whether to verify the tls/ssl certificate.
              "s3VerifySSL": "",

              # s3UseVirtualBucket configures whether it is a virtual bucket or not.
              "s3UseVirtualBucket": "",

              # s3UseAnonymousCredential configures whether to use anonymous credentials to download the model or not.
              "s3UseAnonymousCredential": "",

              # s3CABundle specifies the path to a certificate bundle to use for HTTPS certificate validation.
              "s3CABundle": ""
          }
       }

     # ====================================== INGRESS CONFIGURATION ======================================
     # Example
     ingress: |-
       {   
           "enableGatewayApi": false,
           "kserveIngressGateway" : "kserve/kserve-ingress-gateway",
           "ingressGateway" : "knative-serving/knative-ingress-gateway",
           "localGateway" : "knative-serving/knative-local-gateway",
           "localGatewayService" : "knative-local-gateway.istio-system.svc.cluster.local",
           "ingressDomain"  : "example.com",
           "additionalIngressDomains": ["additional-example.com", "additional-example-1.com"],
           "ingressClassName" : "istio",
           "domainTemplate": "-.",
           "urlScheme": "http",
           "disableIstioVirtualHost": false,
           "disableIngressCreation": false
       }
     ingress: |-
       {   
           # enableGatewayApi specifies whether to use Gateway API instead of Ingress for serving external traffic.
           "enableGatewayApi": false,
           
           # KServe implements [Gateway API](https://gateway-api.sigs.k8s.io/) to serve external traffic. 
           # By default, KServe configures a default gateway to serve external traffic.
           # But, KServe can be configured to use a custom gateway by modifying this configuration.
           # The gateway should be specified in format <gateway namespace>/<gateway name>
           # NOTE: This configuration only applicable for raw deployment.
           "kserveIngressGateway": "kserve/kserve-ingress-gateway",
           
           # ingressGateway specifies the ingress gateway to serve external traffic.
           # The gateway should be specified in format <gateway namespace>/<gateway name>
           # NOTE: This configuration only applicable for serverless deployment with Istio configured as network layer.
           "ingressGateway" : "knative-serving/knative-ingress-gateway",

           # knativeLocalGatewayService specifies the hostname of the Knative's local gateway service.
           # The default KServe configurations are re-using the Istio local gateways for Knative. In this case, this
           # knativeLocalGatewayService field can be left unset. When unset, the value of "localGatewayService" will be used.
           # However, sometimes it may be better to have local gateways specifically for KServe (e.g. when enabling strict mTLS in Istio).
           # Under such setups where KServe is needed to have its own local gateways, the values of the "localGateway" and
           # "localGatewayService" should point to the KServe local gateways. Then, this knativeLocalGatewayService field
           # should point to the Knative's local gateway service.
           # NOTE: This configuration only applicable for serverless deployment with Istio configured as network layer.
           "knativeLocalGatewayService": "",

           # localGateway specifies the gateway which handles the network traffic within the cluster.
           # NOTE: This configuration only applicable for serverless deployment with Istio configured as network layer.
           "localGateway" : "knative-serving/knative-local-gateway",

           # localGatewayService specifies the hostname of the local gateway service.
           # NOTE: This configuration only applicable for serverless deployment with Istio configured as network layer.
           "localGatewayService" : "knative-local-gateway.istio-system.svc.cluster.local",

           # ingressDomain specifies the domain name which is used for creating the url.
           # If ingressDomain is empty then example.com is used as default domain.
           # NOTE: This configuration only applicable for raw deployment.
           "ingressDomain"  : "example.com",

           # additionalIngressDomains specifies the additional domain names which are used for creating the url.
           "additionalIngressDomains": ["additional-example.com", "additional-example-1.com"]

           # ingressClassName specifies the ingress controller to use for ingress traffic.
           # This is optional and if omitted the default ingress in the cluster is used.
           # https://kubernetes.io/docs/concepts/services-networking/ingress/#default-ingress-class
           # NOTE: This configuration only applicable for raw deployment.
           "ingressClassName" : "istio",

           # domainTemplate specifies the template for generating domain/url for each inference service by combining variable from:
           # Name of the inference service  ({{ .Name }})
           # Namespace of the inference service ({{ .Namespace }})
           # Annotation of the inference service ({{ .Annotations.key }})
           # Label of the inference service ({{ .Labels.key }})
           # IngressDomain ({{ .IngressDomain }})
           # If domain template is empty the default template ({{ .Name }}-{{ .Namespace }}.{{ .IngressDomain }}) is used.
           # NOTE: This configuration only applicable for raw deployment.
           "domainTemplate": "-.",

           # urlScheme specifies the url scheme to use for inference service and inference graph.
           # If urlScheme is empty then by default http is used.
           "urlScheme": "http",

           # disableIstioVirtualHost controls whether to use istio as network layer.
           # By default istio is used as the network layer. When DisableIstioVirtualHost is true, KServe does not
           # create the top level virtual service thus Istio is no longer required for serverless mode.
           # By setting this field to true, user can use other networking layers supported by knative.
           # For more info https://github.com/kserve/kserve/pull/2380, https://kserve.github.io/website/master/admin/serverless/kourier_networking/.
           # NOTE: This configuration is only applicable to serverless deployment.
           "disableIstioVirtualHost": false,

           # disableIngressCreation controls whether to disable ingress creation for raw deployment mode.
           "disableIngressCreation": false,

           # pathTemplate specifies the template for generating path based url for each inference service.
           # The following variables can be used in the template for generating url.
           # Name of the inference service ({{ .Name }})
           # Namespace of the inference service ({{ .Namespace }})
           # For more info https://github.com/kserve/kserve/issues/2257.
           # NOTE: This configuration only applicable to serverless deployment.
           "pathTemplate": "/serving//"
       }

     # ====================================== LOGGER CONFIGURATION ======================================
     # Example
     logger: |-
       {
           "image" : "kserve/agent:latest",
           "memoryRequest": "100Mi",
           "memoryLimit": "1Gi",
           "cpuRequest": "100m",
           "cpuLimit": "1",
           "defaultUrl": "http://default-broker"
       }
     logger: |-
       {
           # image contains the default logger image uri.
           "image" : "kserve/agent:latest",

           # memoryRequest is the requests.memory to set for the logger container.
           "memoryRequest": "100Mi",

           # memoryLimit is the limits.memory to set for the logger container.
           "memoryLimit": "1Gi",

           # cpuRequest is the requests.cpu to set for the logger container.
           "cpuRequest": "100m",

           # cpuLimit is the limits.cpu to set for the logger container.
           "cpuLimit": "1",

           # defaultUrl specifies the default logger url. If logger is not specified in the resource this url is used.
           "defaultUrl": "http://default-broker"
       }

     # ====================================== BATCHER CONFIGURATION ======================================
     # Example
     batcher: |-
       {
           "image" : "kserve/agent:latest",
           "memoryRequest": "1Gi",
           "memoryLimit": "1Gi",
           "cpuRequest": "1",
           "cpuLimit": "1",
           "maxBatchSize": "32",
           "maxLatency": "5000"
       }
     batcher: |-
       {
           # image contains the default batcher image uri.
           "image" : "kserve/agent:latest",

           # memoryRequest is the requests.memory to set for the batcher container.
           "memoryRequest": "1Gi",

           # memoryLimit is the limits.memory to set for the batcher container.
           "memoryLimit": "1Gi",

           # cpuRequest is the requests.cpu to set for the batcher container.
           "cpuRequest": "1",

           # cpuLimit is the limits.cpu to set for the batcher container.
           "cpuLimit": "1"

           # maxBatchSize is the default maximum batch size for batcher.
           "maxBatchSize": "32",

           # maxLatency is the default maximum latency in milliseconds for batcher to wait and collect the batch.
           "maxLatency": "5000"
       }

     # ====================================== AGENT CONFIGURATION ======================================
     # Example
     agent: |-
       {
           "image" : "kserve/agent:latest",
           "memoryRequest": "100Mi",
           "memoryLimit": "1Gi",
           "cpuRequest": "100m",
           "cpuLimit": "1"
       }
     agent: |-
       {
           # image contains the default agent image uri.
           "image" : "kserve/agent:latest",

           # memoryRequest is the requests.memory to set for the agent container.
           "memoryRequest": "100Mi",

           # memoryLimit is the limits.memory to set for the agent container.
           "memoryLimit": "1Gi",

           # cpuRequest is the requests.cpu to set for the agent container.
           "cpuRequest": "100m",

           # cpuLimit is the limits.cpu to set for the agent container.
           "cpuLimit": "1"
       }

     # ====================================== ROUTER CONFIGURATION ======================================
     # Example
     router: |-
       {
           "image" : "kserve/router:latest",
           "memoryRequest": "100Mi",
           "memoryLimit": "1Gi",
           "cpuRequest": "100m",
           "cpuLimit": "1",
           "headers": {
             "propagate": []
           },
           "imagePullPolicy": "IfNotPresent",
           "imagePullSecrets": ["docker-secret"]
       }
     # router is the implementation of inference graph.
     router: |-
       {
           # image contains the default router image uri.
           "image" : "kserve/router:latest",

           # memoryRequest is the requests.memory to set for the router container.
           "memoryRequest": "100Mi",

           # memoryLimit is the limits.memory to set for the router container.
           "memoryLimit": "1Gi",

           # cpuRequest is the requests.cpu to set for the router container.
           "cpuRequest": "100m",

           # cpuLimit is the limits.cpu to set for the router container.
           "cpuLimit": "1"

           # Propagate the specified headers to all the steps specified in an InferenceGraph.
           # You can either specify the exact header names or use [Golang supported regex patterns]
           # (https://pkg.go.dev/regexp/syntax@go1.21.3#hdr-Syntax) to propagate multiple headers.
           "headers": {
             "propagate": [
                "Authorization",
                "Test-Header-*",
                "*Trace-Id*"
             ]
           },

           # imagePullPolicy specifies when the router image should be pulled from registry.
           "imagePullPolicy": "IfNotPresent",
          
          # imagePullSecrets specifies the list of secrets to be used for pulling the router image from registry.
          # https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
          "imagePullSecrets": ["docker-secret"]
       }

     # ====================================== DEPLOYMENT CONFIGURATION ======================================
     # Example
     deploy: |-
       {
         "defaultDeploymentMode": "Serverless"
       }
     deploy: |-
       {
         # defaultDeploymentMode specifies the default deployment mode of the kserve. The supported values are
         # Serverless, RawDeployment and ModelMesh. Users can override the deployment mode at service level
         # by adding the annotation serving.kserve.io/deploymentMode.For more info on deployment mode visit
         # Serverless https://kserve.github.io/website/master/admin/serverless/serverless/
         # RawDeployment https://kserve.github.io/website/master/admin/kubernetes_deployment/
         # ModelMesh https://kserve.github.io/website/master/admin/modelmesh/
         "defaultDeploymentMode": "Serverless"
       }

     # ====================================== SERVICE CONFIGURATION ======================================
     # Example
     service: |-
       {
         "serviceClusterIPNone": false
       }
     service: |-
       {
          # ServiceClusterIPNone is a flag to indicate if the service should have a clusterIP set to None.
          # If the DeploymentMode is Raw, the default value for ServiceClusterIPNone if not set is false
          # "serviceClusterIPNone": false
       }

     # ====================================== METRICS CONFIGURATION ======================================
     # Example
     metricsAggregator: |-
       {
         "enableMetricAggregation": "false",
         "enablePrometheusScraping" : "false"
       }
     # For more info see https://github.com/kserve/kserve/blob/master/qpext/README.md
     metricsAggregator: |-
       {
         # enableMetricAggregation configures metric aggregation annotation. This adds the annotation serving.kserve.io/enable-metric-aggregation to every
         # service with the specified boolean value. If true enables metric aggregation in queue-proxy by setting env vars in the queue proxy container
         # to configure scraping ports.
         "enableMetricAggregation": "false",

         # enablePrometheusScraping configures metric aggregation annotation. This adds the annotation serving.kserve.io/enable-metric-aggregation to every
         # service with the specified boolean value. If true, prometheus annotations are added to the pod. If serving.kserve.io/enable-metric-aggregation is false,
         # the prometheus port is set with the default prometheus scraping port 9090, otherwise the prometheus port annotation is set with the metric aggregation port.
         "enablePrometheusScraping" : "false"
       }

     # ====================================== LOCALMODEL CONFIGURATION ======================================
     # Example
     localModel: |-
       {
         "enabled": false,
         # jobNamespace specifies the namespace where the download job will be created.
         "jobNamespace": "kserve-localmodel-jobs",
         # defaultJobImage specifies the default image used for the download job.
         "defaultJobImage" : "kserve/storage-initializer:latest",
         # Kubernetes modifies the filesystem group ID on the attached volume.
         "fsGroup": 1000,
         # TTL for the download job after it is finished.
         "jobTTLSecondsAfterFinished": 3600,
         # The frequency at which the local model agent reconciles the local models
         # This is to detect if models are missing from local disk
         "reconcilationFrequencyInSecs": 60
         # This is to disable localmodel pv and pvc management for namespaces without isvcs
         "disableVolumeManagement": false
       }

  agent: |-
    {
        "image" : "kserve/agent:v0.15.2",
        "memoryRequest": "100Mi",
        "memoryLimit": "1Gi",
        "cpuRequest": "100m",
        "cpuLimit": "1"
    }
  batcher: |-
    {
        "image" : "kserve/agent:v0.15.2",
        "memoryRequest": "1Gi",
        "memoryLimit": "1Gi",
        "cpuRequest": "1",
        "cpuLimit": "1",
        "maxBatchSize": "32",
        "maxLatency": "5000"
    }
  router: |-
    {
        "image" : "kserve/router:v0.15.2",
        "memoryRequest": "100Mi",
        "memoryLimit": "1Gi",
        "cpuRequest": "100m",
        "cpuLimit": "1",
        "imagePullPolicy": "IfNotPresent",
        "imagePullSecrets": []
    }
  credentials: |-
    {
       "storageSpecSecretName": "storage-config",
       "storageSecretNameAnnotation": "serving.kserve.io/secretName",
       "gcs": {
           "gcsCredentialFileName": "gcloud-application-credentials.json"
       },
       "s3": {
           "s3AccessKeyIDName": "AWS_ACCESS_KEY_ID",
           "s3SecretAccessKeyName": "AWS_SECRET_ACCESS_KEY",
           "s3Endpoint": "",
           "s3UseHttps": "",
           "s3Region": "",
           "s3VerifySSL": "",
           "s3UseVirtualBucket": "",
           "s3UseAnonymousCredential": "",
           "s3CABundle": ""
       }
    }
  deploy: |-
    {
      "defaultDeploymentMode": "RawDeployment"
    }
  service: |-
    {
      "serviceClusterIPNone": false
    }
  explainers: |-
    {
        "art": {
            "image" : "kserve/art-explainer",
            "defaultImageVersion": "v0.15.2"
        }
    }
  ingress: |-
    {   
        "enableGatewayApi": false,
        "kserveIngressGateway" : "kserve/kserve-ingress-gateway",
        "ingressGateway" : "knative-serving/knative-ingress-gateway",
        "knativeLocalGatewayService" : "",
        "localGateway" : "knative-serving/knative-local-gateway",
        "localGatewayService" : "knative-local-gateway.istio-system.svc.cluster.local",
        "ingressClassName" : "istio",
        "ingressDomain"  : "example.com",
        "additionalIngressDomains": [
        ],
        "domainTemplate": "{{ .Name }}-{{ .Namespace }}.{{ .IngressDomain }}",
        "urlScheme": "http",
        "disableIstioVirtualHost": false,
        "disableIngressCreation": false
    }
  logger: |-
    {
        "image" : "kserve/agent:v0.15.2",
        "memoryRequest": "100Mi",
        "memoryLimit": "1Gi",
        "cpuRequest": "100m",
        "cpuLimit": "1",
        "defaultUrl": "http://default-broker"
    }
  storageInitializer: |-
    {
        "image" : "kserve/storage-initializer:v0.15.2",
        "memoryRequest": "100Mi",
        "memoryLimit": "1Gi",
        "cpuRequest": "100m",
        "cpuLimit": "1",
        "enableDirectPvcVolumeMount": true,
        "caBundleConfigMapName": "",
        "caBundleVolumeMountPath": "/etc/ssl/custom-certs",
        "enableModelcar": true,
        "cpuModelcar": "10m",
        "memoryModelcar": "15Mi"
    }
  metricsAggregator: |-
    {
      "enableMetricAggregation": "false",
      "enablePrometheusScraping" : "false"
    }
  localModel: |-
    {
      "enabled": false,
      "jobNamespace": "kserve-localmodel-jobs",
      "jobTTLSecondsAfterFinished": 3600,
      "defaultJobImage": "kserve/storage-initializer:latest",
      "fsGroup": 1000,
      "reconcilationFrequencyInSecs": 60,
      "disableVolumeManagement": false
    }
  security: |-
    {
      "autoMountServiceAccountToken": true
    }

  inferenceService: |-
    {
      "resource": {
        "cpuLimit": "1",
        "cpuRequest": "1",
        "memoryLimit": "2Gi",
        "memoryRequest": "2Gi"
      }
    }

  opentelemetryCollector: |-
    {
      "scrapeInterval": "5s",
      "metricReceiverEndpoint": "keda-otel-scaler.keda.svc:4317",
      "metricScalerEndpoint": "keda-otel-scaler.keda.svc:4318"
    }
---
# Source: kserve/templates/clusterrole.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: kserve-proxy-role
rules:
- apiGroups: ["authentication.k8s.io"]
  resources:
  - tokenreviews
  verbs: ["create"]
- apiGroups: ["authorization.k8s.io"]
  resources:
  - subjectaccessreviews
  verbs: ["create"]
---
# Source: kserve/templates/clusterrole.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: kserve-manager-role
rules:
- apiGroups:
  - ""
  resources:
  - configmaps
  verbs:
  - create
  - get
  - update
- apiGroups:
  - ""
  resources:
  - events
  - services
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - ""
  resources:
  - namespaces
  - pods
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - ""
  resources:
  - secrets
  - serviceaccounts
  verbs:
  - get
- apiGroups:
  - admissionregistration.k8s.io
  resources:
  - mutatingwebhookconfigurations
  - validatingwebhookconfigurations
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - apps
  resources:
  - deployments
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - autoscaling
  resources:
  - horizontalpodautoscalers
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - gateway.networking.k8s.io
  resources:
  - httproutes
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - keda.sh
  resources:
  - scaledobjects
  - scaledobjects/finalizers
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - keda.sh
  resources:
  - scaledobjects/status
  verbs:
  - get
  - patch
  - update
- apiGroups:
  - networking.istio.io
  resources:
  - virtualservices
  - virtualservices/finalizers
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - networking.istio.io
  resources:
  - virtualservices/status
  verbs:
  - get
  - patch
  - update
- apiGroups:
  - networking.k8s.io
  resources:
  - ingresses
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - opentelemetry.io
  resources:
  - opentelemetrycollectors
  - opentelemetrycollectors/finalizers
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - opentelemetry.io
  resources:
  - opentelemetrycollectors/status
  verbs:
  - get
  - patch
  - update
- apiGroups:
  - serving.knative.dev
  resources:
  - services
  - services/finalizers
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - serving.knative.dev
  resources:
  - services/status
  verbs:
  - get
  - patch
  - update
- apiGroups:
  - serving.kserve.io
  resources:
  - clusterservingruntimes
  - clusterservingruntimes/finalizers
  - clusterstoragecontainers
  - inferencegraphs
  - inferencegraphs/finalizers
  - inferenceservices
  - inferenceservices/finalizers
  - servingruntimes
  - servingruntimes/finalizers
  - trainedmodels
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - serving.kserve.io
  resources:
  - clusterservingruntimes/status
  - inferencegraphs/status
  - inferenceservices/status
  - servingruntimes/status
  - trainedmodels/status
  verbs:
  - get
  - patch
  - update
- apiGroups:
  - serving.kserve.io
  resources:
  - localmodelcaches
  verbs:
  - get
  - list
  - watch
---
# Source: kserve/templates/clusterrolebinding.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: kserve-proxy-rolebinding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: kserve-proxy-role
subjects:
- kind: ServiceAccount
  name: kserve-controller-manager
  namespace: kserve
---
# Source: kserve/templates/clusterrolebinding.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: kserve-manager-rolebinding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: kserve-manager-role
subjects:
- kind: ServiceAccount
  name: kserve-controller-manager
  namespace: kserve
---
# Source: kserve/templates/role.yaml
# permissions to do leader election.
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: kserve-leader-election-role
rules:
- apiGroups:
  - coordination.k8s.io
  resources:
  - leases
  verbs:
  - create
  - get
  - list
  - update
- apiGroups:
  - ""
  resources:
  - configmaps
  verbs:
  - get
  - list
  - watch
  - create
  - update
  - patch
  - delete
- apiGroups:
  - ""
  resources:
  - configmaps/status
  verbs:
  - get
  - update
  - patch
- apiGroups:
  - ""
  resources:
  - events
  verbs:
  - create
---
# Source: kserve/templates/rolebinding.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: kserve-leader-election-rolebinding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: kserve-leader-election-role
subjects:
- kind: ServiceAccount
  name: kserve-controller-manager
  namespace: kserve
---
# Source: kserve/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: kserve-webhook-server-service
  namespace: kserve
spec:
  ports:
    - port: 443
      targetPort: webhook-server
  selector:
    control-plane: kserve-controller-manager
---
# Source: kserve/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: kserve-controller-manager-service
  namespace: kserve
  labels:
    control-plane: kserve-controller-manager
    controller-tools.k8s.io: "1.0"
spec:
  selector:
    control-plane: kserve-controller-manager
    controller-tools.k8s.io: "1.0"
  ports:
  - port: 8443
    targetPort: https
    protocol: TCP
---
# Source: kserve/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: kserve-controller-manager
  namespace: kserve
  labels:
    app.kubernetes.io/name: kserve-controller-manager
    control-plane: kserve-controller-manager
    controller-tools.k8s.io: "1.0"
  annotations:
    prometheus.io/scrape: 'true'
spec:
  selector:
    matchLabels:
      control-plane: kserve-controller-manager
      controller-tools.k8s.io: "1.0"
  template:
    metadata:
      labels:
        app.kubernetes.io/name: kserve-controller-manager
        control-plane: kserve-controller-manager
        controller-tools.k8s.io: "1.0"
      annotations:
        kubectl.kubernetes.io/default-container: manager
    spec:
      serviceAccountName: kserve-controller-manager
      securityContext:
        runAsNonRoot: true
      containers:
      - name: kube-rbac-proxy
        image: "quay.io/brancz/kube-rbac-proxy:v0.18.0"
        args:
        - "--secure-listen-address=0.0.0.0:8443"
        - "--upstream=http://127.0.0.1:8080/"
        - "--logtostderr=true"
        - "--v=10"
        ports:
        - containerPort: 8443
          name: https
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - ALL
          privileged: false
          readOnlyRootFilesystem: true
          runAsNonRoot: true
        resources:
          limits:
            cpu: 100m
            memory: 300Mi
          requests:
            cpu: 100m
            memory: 300Mi
      - command:
        - /manager
        image: "kserve/kserve-controller:v0.15.2"
        imagePullPolicy: IfNotPresent
        name: manager
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - ALL
          privileged: false
          readOnlyRootFilesystem: true
          runAsNonRoot: true
        args:
        - "--metrics-addr=127.0.0.1:8080"
        - "--leader-elect"
        env:
          - name: POD_NAMESPACE
            valueFrom:
              fieldRef:
                fieldPath: metadata.namespace
          - name: SECRET_NAME
            value: kserve-webhook-server-cert
        livenessProbe:
          failureThreshold: 5
          initialDelaySeconds: 30
          httpGet:
            path: /healthz
            port: 8081
          timeoutSeconds: 5
        readinessProbe:
          initialDelaySeconds: 30
          failureThreshold: 5
          periodSeconds: 5
          httpGet:
            path: /readyz
            port: 8081
          timeoutSeconds: 5
        resources:
            limits:
              cpu: 100m
              memory: 300Mi
            requests:
              cpu: 100m
              memory: 300Mi
        ports:
        - containerPort: 9443
          name: webhook-server
          protocol: TCP
        - containerPort: 8080
          name: metrics
          protocol: TCP
        volumeMounts:
        - mountPath: /tmp/k8s-webhook-server/serving-certs
          name: cert
          readOnly: true
      terminationGracePeriodSeconds: 10
      volumes:
      - name: cert
        secret:
          defaultMode: 420
          secretName: kserve-webhook-server-cert
---
# Source: kserve/templates/webhookconfiguration.yaml
apiVersion: admissionregistration.k8s.io/v1
kind: MutatingWebhookConfiguration
metadata:
  name: inferenceservice.serving.kserve.io
  annotations:
    cert-manager.io/inject-ca-from: kserve/serving-cert
webhooks:
  - clientConfig:
      service:
        name: kserve-webhook-server-service
        namespace: kserve
        path: /mutate-serving-kserve-io-v1beta1-inferenceservice
    failurePolicy: Fail
    name: inferenceservice.kserve-webhook-server.defaulter
    sideEffects: None
    admissionReviewVersions: ["v1beta1"]
    rules:
      - apiGroups:
          - serving.kserve.io
        apiVersions:
          - v1beta1
        operations:
          - CREATE
          - UPDATE
        resources:
          - inferenceservices
  - clientConfig:
      service:
        name: kserve-webhook-server-service
        namespace: kserve
        path: /mutate-pods
    failurePolicy: Fail
    name: inferenceservice.kserve-webhook-server.pod-mutator
    sideEffects: None
    reinvocationPolicy: IfNeeded
    admissionReviewVersions: ["v1beta1"]
    objectSelector:
      matchExpressions:
        - key: serving.kserve.io/inferenceservice
          operator: Exists
    rules:
      - apiGroups:
          - ""
        apiVersions:
          - v1
        operations:
          - CREATE
        resources:
          - pods
---
# Source: kserve/templates/webhookconfiguration.yaml
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  name: inferenceservice.serving.kserve.io
  annotations:
    cert-manager.io/inject-ca-from: kserve/serving-cert
webhooks:
  - clientConfig:
      service:
        name: kserve-webhook-server-service
        namespace: kserve
        path: /validate-serving-kserve-io-v1beta1-inferenceservice
    failurePolicy: Fail
    name: inferenceservice.kserve-webhook-server.validator
    sideEffects: None
    admissionReviewVersions: ["v1beta1"]
    rules:
      - apiGroups:
          - serving.kserve.io
        apiVersions:
          - v1beta1
        operations:
          - CREATE
          - UPDATE
        resources:
          - inferenceservices
---
# Source: kserve/templates/webhookconfiguration.yaml
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  name: trainedmodel.serving.kserve.io
  annotations:
    cert-manager.io/inject-ca-from: kserve/serving-cert
webhooks:
  - clientConfig:
      service:
        name: kserve-webhook-server-service
        namespace: kserve
        path: /validate-serving-kserve-io-v1alpha1-trainedmodel
    failurePolicy: Fail
    name: trainedmodel.kserve-webhook-server.validator
    sideEffects: None
    admissionReviewVersions: ["v1beta1"]
    rules:
      - apiGroups:
          - serving.kserve.io
        apiVersions:
          - v1alpha1
        operations:
          - CREATE
          - UPDATE
        resources:
          - trainedmodels
---
# Source: kserve/templates/webhookconfiguration.yaml
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  creationTimestamp: null
  name: inferencegraph.serving.kserve.io
  annotations:
    cert-manager.io/inject-ca-from: kserve/serving-cert
webhooks:
  - clientConfig:
      service:
        name: kserve-webhook-server-service
        namespace: kserve
        path: /validate-serving-kserve-io-v1alpha1-inferencegraph
    failurePolicy: Fail
    name: inferencegraph.kserve-webhook-server.validator
    sideEffects: None
    admissionReviewVersions: ["v1beta1"]
    rules:
      - apiGroups:
          - serving.kserve.io
        apiVersions:
          - v1alpha1
        operations:
          - CREATE
          - UPDATE
        resources:
          - inferencegraphs
---
# Source: kserve/templates/webhookconfiguration.yaml
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  creationTimestamp: null
  name: clusterservingruntime.serving.kserve.io
  annotations:
    cert-manager.io/inject-ca-from: kserve/serving-cert
webhooks:
  - clientConfig:
      service:
        name: kserve-webhook-server-service
        namespace: kserve
        path: /validate-serving-kserve-io-v1alpha1-clusterservingruntime
    failurePolicy: Fail
    name: clusterservingruntime.kserve-webhook-server.validator
    sideEffects: None
    admissionReviewVersions: ["v1beta1"]
    rules:
      - apiGroups:
          - serving.kserve.io
        apiVersions:
          - v1alpha1
        operations:
          - CREATE
          - UPDATE
        resources:
          - clusterservingruntimes
---
# Source: kserve/templates/webhookconfiguration.yaml
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  creationTimestamp: null
  name: servingruntime.serving.kserve.io
  annotations:
    cert-manager.io/inject-ca-from: kserve/serving-cert
webhooks:
  - clientConfig:
      service:
        name: kserve-webhook-server-service
        namespace: kserve
        path: /validate-serving-kserve-io-v1alpha1-servingruntime
    failurePolicy: Fail
    name: servingruntime.kserve-webhook-server.validator
    sideEffects: None
    admissionReviewVersions: ["v1beta1"]
    rules:
      - apiGroups:
          - serving.kserve.io
        apiVersions:
          - v1alpha1
        operations:
          - CREATE
          - UPDATE
        resources:
          - servingruntimes
---
# Source: kserve/templates/webhookconfiguration.yaml
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  creationTimestamp: null
  name: localmodelcache.serving.kserve.io
  annotations:
    cert-manager.io/inject-ca-from: kserve/serving-cert
webhooks:
  - clientConfig:
      service:
        name: kserve-webhook-server-service
        namespace: kserve
        path: /validate-serving-kserve-io-v1alpha1-localmodelcache
    failurePolicy: Fail
    name: localmodelcache.kserve-webhook-server.validator
    sideEffects: None
    admissionReviewVersions: ["v1beta1"]
    rules:
      - apiGroups:
          - serving.kserve.io
        apiVersions:
          - v1alpha1
        operations:
          - CREATE
          - UPDATE
          - DELETE
        resources:
          - localmodelcaches
---
# Source: kserve/templates/certificate.yaml
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: serving-cert
  namespace: kserve
spec:
  commonName: kserve-webhook-server-service.kserve.svc
  dnsNames:
  - kserve-webhook-server-service.kserve.svc
  issuerRef:
    kind: Issuer
    name: selfsigned-issuer
  secretName: kserve-webhook-server-cert
---
# Source: kserve/templates/certificate.yaml
apiVersion: cert-manager.io/v1
kind: Issuer
metadata:
  name: selfsigned-issuer
  namespace: kserve
spec:
  selfSigned: {}
